<!doctype html>
<html lang="en">
<head>
    <title>Info Cube viz</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!--<link rel=stylesheet href="css/base.css"/>-->
    <script src="node_modules/three/three.js"></script>
    <script src="node_modules/tween.js"></script>
    <script src="js/Detector.js"></script>
    <!--<script src="js/Stats.js"></script>-->
    <!--<script src="js/OrbitControls.js"></script>-->
    <script src="js/THREEx.KeyboardState.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <script src="js/OrbitControls.js"></script>

    <!-- jQuery code to display an information button and box when clicked. -->
    <script src="node_modules/jquery/dist/jquery.js"></script>
    <script src="node_modules/jquery-ui/jquery-ui.js"></script>
    <link rel=stylesheet href="node_modules/jquery-ui/themes/base/jquery-ui.css"/>
</head>
<body>


<!-- ------------------------------------------------------------ -->

<div id="three" style="z-index: 1; position: relative; left:0px; top:0px"></div>

<div style="width: 100px"></div>>
<script>

    // MAIN

    // standard global variables
    var container, scene, camera, renderer, controls, stats, light;
    var keyboard = new THREEx.KeyboardState();
    var clock = new THREE.Clock();
    // custom global variables
    var cube;

    init();
    animate();

    function init() {

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 200;
        camera.position.x = 300;
        camera.position.y = 400;

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize( window.innerWidth, window.innerHeight );

        controls = new THREE.OrbitControls( camera, renderer.domElement );

        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({ charCode : 'f'.charCodeAt(0) });


        mesh = new Box({size: 200, order: 4});
        tutu = mesh;
//        mesh2 = new Box({size: 50, color: 0xf0019f, order: 3});

        updateBoundingBox(mesh);
//        updateBoundingBox(mesh2);

//        mesh3 = new Box({size: 20, color: 0x00ff00, order: 2});

        for(var i = 0; i < 10; ++i ) {
            createChild(mesh, {size: 30, color: 0xf0019f, order: 3});
        }

        mesh.children.forEach(function(node){
            for(var i = 0 ; i< 3; i++){
                createChild(node,{size: 10, color: 0xa0ff00});
//                node.translateX(Math.random()*2-1);
//                node.translateY(Math.random()*2-1);
//                node.translateZ(Math.random()*2-1);
            }
//            node.children.forEach(function(_){
//                _.translateX(Math.random()*2-1);
//                _.translateY(Math.random()*2-1);
//                _.translateZ(Math.random()*2-1);
//            })
        });

        scene.add( mesh );

        var ambientLight = new THREE.AmbientLight(0x101010, 5.0);
        scene.add(ambientLight);

        scene.add(SkyBox());
        scene.fog = new THREE.FogExp2( 0xffffff, 0.00025 );


        light = new THREE.PointLight(0xffffff);
        light.position = camera.position;
        scene.add(light);

        document.body.appendChild( renderer.domElement );

    }

    function Box(options){
        var options = options || {};

        var color = options.color || 0xff0000;
        var opacity = options.opacity || 0.7;
        var size = options.size || 10;
        var name = options.name || "none";
        var order = options.order || 0;

        var geo = new THREE.BoxGeometry(size,size,size);

        var material = new THREE.MeshLambertMaterial({
//            depthWrite: false,
            transparent: true,
            color: color,
            opacity: opacity,
            side: THREE.BackSide,
            combine: THREE.AdditiveBlending
        });

        m = new THREE.Mesh(geo, material );
        m.name = name;
        m.renderOrder = order;

        return m;
    }

    var arrangeChildren = function(cube){
        if(cube.children.length === 0)
            return;

        var passes = 300;

        updateBoundingBox(cube);
        var children = cube.children;

        for(var i = 0; i < children.length; i++){
            updateBoundingBox(children[i]);
        }

        for(var i = 0; i < passes; i++ ){
            for(var j = 0; j < children.length; j++){
                var currentChild = children[j];

                for( var k = 1; k < children.length; k++){
                    //computes position of child which is to move
                    childToMoveIndex = (j + k + children.length) % children.length;
                    childToMove = children[childToMoveIndex];

                    //creates a normalized vector currentChild -> childToMove
                    vector = childToMove.position.clone().sub(currentChild.position).normalize();

                    //creates a decoiy box and tests if it is still in the parent mesh
                    decoy = new THREE.Box3().setFromObject( childToMove );
                    decoy.position = childToMove.position.clone();
                    decoy.position.add(vector); //.multiplyScalar(Math.floor(Math.random()*5+1))

                    //if it is in the parent mesh we should update the child's
                    // position and its bounding box
                    if(cube.geometry.boundingBox.containsBox(decoy)){
                        childToMove.position.set(decoy.position.x,decoy.position.y,decoy.position.z);
                        updateBoundingBox(childToMove);
                    }

                }
            }
        }

        cube.children.forEach(arrangeChildren);
    };

    function createChild(box,options){
        child = new Box(options);

        box.geometry.computeBoundingBox();

        child.geometry.computeBoundingBox();

        //randomly alter the childs location from (0,0,0)
        child.position.set(
                Math.random() * 2 -1,
                Math.random() * 2 -1,
                Math.random() * 2 -1
        );

        box.add(child);
    }

    function doesNotIntersect(box,children){

        box.boundingBox;

        for( var i = 0; i < children.length; i++){
            if(children[i].geometry.isIntersectionBox(box.geometry.boundingBox))
                return false;
        }

        return true;
    }

    function updateBoundingBox(box){
        if(box.geometry.boundingBox === null){
            box.geometry.computeBoundingBox();
        } else {
            box.geometry.boundingBox.setFromObject(box);
        }
    }

    function Floor(){
        var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xf4a460, side: THREE.DoubleSide } );
        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -100;
        floor.rotation.x = Math.PI / 2;
        return floor;
    }

    function SkyBox(){
        var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
        var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
        var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
        return skyBox;
    }

    function animate()
    {
        requestAnimationFrame( animate );

//        mesh.rotation.x += 0.01;
//        mesh.rotation.y += 0.02;

//        if(mesh.geometry.boundingBox.containsBox(mesh3.geometry.boundingBox)) {
//            mesh3.translateX(1);
//            mesh3.geometry.boundingBox.setFromObject(mesh3);
//        }

//        console.log(light.position);
//        console.log(camera.position);
//        console.log('-----');
        light.position.set(camera.position.x,camera.position.y,camera.position.z);

        update();
        render();
    }

    function update(time)
    {
        if ( keyboard.pressed("z") )
        {
            // do something
        }

//        new TWEEN.Tween( cube.scale ).to( { y: 10 }, 3000 );
        TWEEN.update(time);
        controls.update();
    }

    function render()
    {
        renderer.render( scene, camera );
    }

</script>

</body>
</html>
