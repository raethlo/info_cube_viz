<!doctype html>
<html lang="en">
<head>
    <title>Info Cube viz</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!--<link rel=stylesheet href="css/base.css"/>-->
    <script src="node_modules/three/three.js"></script>
    <script src="node_modules/tween.js"></script>
    <script src="js/Detector.js"></script>
    <!--<script src="js/Stats.js"></script>-->
    <!--<script src="js/OrbitControls.js"></script>-->
    <script src="js/THREEx.KeyboardState.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <script src="js/OrbitControls.js"></script>

    <!-- jQuery code to display an information button and box when clicked. -->
    <script src="node_modules/jquery/dist/jquery.js"></script>
    <script src="node_modules/jquery-ui/jquery-ui.js"></script>
    <link rel=stylesheet href="node_modules/jquery-ui/themes/base/jquery-ui.css"/>
</head>
<body>


<!-- ------------------------------------------------------------ -->

    <div id="three" style="z-index: 1; position: relative; left:0px; top:0px; float:right"></div>

    <script>
        //TODO dont add node's children if there are too many
        //TODO load data from file
        //TODO picking to zoom/higlight to a node
        //TODO zoom inside ... in the structure
        //TODO render a d3 tree to navigate possibly?
        // MAIN

        // standard global variables
        var container = document.getElementById('three'),
                scene, pickingScene,
                camera,
                renderer,
                controls,
                light,
                root,
                info,
                cubesToIntersect = [];

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector3();

        var keyboard = new THREEx.KeyboardState();
        var clock = new THREE.Clock();
        // custom global variables
        var cube;

        init();
        animate();

        function init() {

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.z = 500;
            camera.position.x = 600;
            camera.position.y = 800;

            scene = new THREE.Scene();

            pickingScene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize( window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xcccccc);

            controls = new THREE.OrbitControls( camera, renderer.domElement );

            THREEx.WindowResize(renderer, camera);
            THREEx.FullScreen.bindKey({ charCode : 'f'.charCodeAt(0) });

            $.getJSON('flare.json', function(r){

                root = createStructure(r, scene);

                info = document.createElement( 'div' );

                info.style.position = 'absolute';
                info.style.top = '10px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = root.name;
                container.appendChild( info );

                if(root.children) {
                    root.children.forEach(function (node) {
                        var size = node.geometry.boundingBox.size().x;
                        var geom = new THREE.BoxGeometry(size,size,size);
                        var mesh = new THREE.Mesh(geom);

                        mesh.position.copy(node.position);
                        mesh.rotation.copy(node.rotation);

                        mesh.userData = node;

                        pickingScene.add(mesh);
                    });
                }
            });

            var ambientLight = new THREE.AmbientLight(0x101010, 5.0);

            scene.add(ambientLight);

            light = new THREE.PointLight(0xffffff);

            light.position = camera.position;
            scene.add(light);
            container.appendChild( renderer.domElement );

            // when the mouse moves, call the given function
            document.addEventListener( 'click', onDocumentMouseClick, false );
        }

        function demoShowCase(scene){
            mesh = new Box({size: 1000, order: 4, color: rainbow(10,1)});

            updateBoundingBox(mesh);

            var rand = Math.floor(Math.random()*60)+3;

            for(var i = 0; i < rand; ++i ) {
                var size = Math.floor(1000/rand*1.2) - 5;
                createChild(mesh, {size: size, color: rainbow(10,2), order: 3});
            }

            mesh.children.forEach(function(node){
                var rand = Math.floor(Math.random()*300)+300;
                var size = Math.floor(node.geometry.boundingBox.size().x / rand * 1.2);

                if(rand < 20)
                    for(var i = 0 ; i< rand; i++){
                        createChild(node,{size: size, color: rainbow(10,3)});
                    }
            });

            scene.add( mesh );
        }

        function Box(options){
            var options = options || {};

            var color = options.color || getRandomColor();
            var opacity = options.opacity || 0.7;
            var size = options.size || 10;
            var name = options.name || "none";
            var order = options.order || 0;

            var geo = new THREE.BoxGeometry(size,size,size);

            var material = new THREE.MeshLambertMaterial({
                transparent: true,
                color: color,
                opacity: opacity,
                side: THREE.BackSide,
                combine: THREE.AdditiveBlending
            });

            m = new THREE.Mesh(geo, material );
            m.name = name;
            m.renderOrder = order;

            return m;
        }

        var arrangeChildren = function(cube){
            if(cube.children.length === 0)
                return;

            var passes = 150;

            updateBoundingBox(cube);
            var children = cube.children;

            for(var i = 0; i < children.length; i++){
                updateBoundingBox(children[i]);
            }

            for(var i = 0; i < passes; i++ ){
                for(var j = 0; j < children.length; j++){
                    var currentChild = children[j];

                    for( var k = 1; k < children.length; k++){
                        //computes position of child which is to move
                        childToMoveIndex = (j + k + children.length) % children.length;
                        childToMove = children[childToMoveIndex];

                        //creates a normalized vector currentChild -> childToMove
                        vector = childToMove.position.clone().sub(currentChild.position).normalize();

                        //creates a decoiy box and tests if it is still in the parent mesh
                        decoy = new THREE.Box3().setFromObject( childToMove );
                        decoy.position = childToMove.position.clone().add(vector);

                        //if it is in the parent mesh we should update the child's
                        // position and its bounding box
                        if(cube.geometry.boundingBox.containsBox(decoy)){
                            childToMove.position.copy(decoy.position);
                            childToMove.updateMatrix();
                        }

                    }
                }
            }

            if(children.length < 20)
                children.forEach(arrangeChildren);
        };

        function createChild(parent,options){
            child = new Box(options);

            parent.geometry.computeBoundingBox();

            child.geometry.computeBoundingBox();

            //randomly alter the childs location from (0,0,0)
            child.position.set(
                    Math.random() * 2 -1,
                    Math.random() * 2 -1,
                    Math.random() * 2 -1
            );

    //        scene.add(child);
            parent.add(child);

            return child;
        }

        function doesNotIntersect(box,children){

            box.boundingBox;

            for( var i = 0; i < children.length; i++){
                if(children[i].geometry.isIntersectionBox(box.geometry.boundingBox))
                    return false;
            }

            return true;
        }

        function updateBoundingBox(box){
            if(box.geometry.boundingBox === null){
                box.geometry.computeBoundingBox();
            } else {
                box.geometry.boundingBox.setFromObject(box);
            }
        }

        function Floor(){
            var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xf4a460, side: THREE.DoubleSide } );
            var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
            var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -100;
            floor.rotation.x = Math.PI / 2;
            return floor;
        }

        function SkyBox(){
            var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
            var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
            var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
            return skyBox;
        }

        function animate()
        {
            requestAnimationFrame( animate );

            light.position.set(camera.position.x,camera.position.y,camera.position.z);

            update();
            render();
        }

        function update(time)
        {
            if ( keyboard.pressed("z") )
            {
                // do something
            }

    //        new TWEEN.Tween( cube.scale ).to( { y: 10 }, 3000 );
            TWEEN.update(time);
            controls.update();
        }

        function render()
        {
            renderer.render( scene, camera );
        }

        function rainbow(numOfSteps, step) {
            // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
            // Adam Cole, 2011-Sept-14
            // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
            var r, g, b;
            var h = step / numOfSteps;
            var i = ~~(h * 6);
            var f = h * 6 - i;
            var q = 1 - f;
            switch(i % 6){
                case 0: r = 1, g = f, b = 0; break;
                case 1: r = q, g = 1, b = 0; break;
                case 2: r = 0, g = 1, b = f; break;
                case 3: r = 0, g = q, b = 1; break;
                case 4: r = f, g = 0, b = 1; break;
                case 5: r = 1, g = 0, b = q; break;
            }
            var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
            return (c);
        }

        function getRandomColor() {
            var letters = '0123456789ABCDEF'.split('');
            var color = '#';
            for (var i = 0; i < 6; i++ ) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function createStructure(data, scene, depthLimit, maxChildrenPerBox){
            depthLimit = depthLimit || 3;
            maxChildrenPerBox = maxChildrenPerBox || 30;

            // i can set the root node render order to depth limit
            // because it also denotes the number of nested levels
            var rootCube = new Box({name: data.name, order: depthLimit + 1, size: 1000, color: rainbow(4,depthLimit + 1)});
            updateBoundingBox(rootCube);
            scene.add(rootCube);

            if (data.children != null) {
                createChildStructure(rootCube, data.children, depthLimit, maxChildrenPerBox);
            }

            arrangeChildren(rootCube);

            return rootCube;

        }

        function createChildStructure(parent, children, depthLimit, maxChildrenPerBox){

            if(depthLimit === 0)
                return;

            if(children.length > maxChildrenPerBox)
                return;

            updateBoundingBox(parent);

            var childSize = Math.floor(parent.geometry.boundingBox.size().x / (children.length + 1) ) + 1;

            for(var i = 0; i < children.length; i++){
                var child = children[i];

                var childBox = createChild(parent, { name: child.name, size: childSize, order: depthLimit + 1, color: rainbow(4, depthLimit) });
                if(depthLimit > 1 && child.children != null){
                    cubesToIntersect.push(childBox);
                    createChildStructure(childBox, child.children, depthLimit -1 , maxChildrenPerBox);
                }
            }


        }

        function onDocumentMouseClick( event )
        {
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            renderer.render(pickingScene,camera);
            mouse.z = 0.5;

            raycaster.setFromCamera( mouse, camera );

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects( pickingScene.children, true );

            for( var i = 0; i < intersects.length; i++ ) {
                var intersection = intersects[ i ],
                        obj = intersection.object;

                info.innerHTML = obj.userData.name;
            }

        }

    </script>

    </body>
</html>
